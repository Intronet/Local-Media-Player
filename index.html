<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Local Audio Player</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      html, body {
        height: 100%;
        background-color: #121212;
        color: #fff;
        font-family: Segoe UI, system-ui, -apple-system, Roboto, "Helvetica Neue", Arial;
        overflow: hidden;
      }
      /* Custom scrollbar for playlist */
      .scrollbar-thin { scrollbar-width: thin; scrollbar-color: #4b5563 #1f2937; }
      .scrollbar-thin::-webkit-scrollbar { width: 8px; }
      .scrollbar-thin::-webkit-scrollbar-track { background: #1f2937; }
      .scrollbar-thin::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 4px; }
      
      /* Hide the organize panel initially */
      #organizePanel.hidden {
        display: none;
      }
    </style>
</head>
<body class="bg-[#121212] text-white font-sans overflow-hidden">
    <div class="h-screen flex flex-col">
        <!-- Main Content Area -->
        <div class="flex-1 relative">
            <canvas id="visualizer" class="absolute top-0 left-0 h-full opacity-25 z-0 transition-all duration-300 ease-in-out"></canvas>

            <main class="absolute inset-0 z-10 p-6 pt-12 text-center overflow-y-auto mr-[300px] transition-all duration-300 ease-in-out">
                <div class="relative z-10">
                    <h1 class="text-4xl font-semibold mb-2">üéµ Local Media Player</h1>
                    <p class="text-[#888] mb-4">Select a folder with .mp3 files. Use ‚Üë/‚Üì to navigate, hold ‚Üê/‚Üí to seek, Space to play/pause.</p>
                    <div class="flex justify-center items-center gap-4">
                        <input id="folderPicker" type="file" webkitdirectory="true" multiple accept=".mp3" class="hidden" />
                        <button id="selectFolderBtn" class="bg-gradient-to-r from-[#00aaff] to-[#00ffee] text-white font-bold py-2 px-6 rounded-lg shadow-lg hover:scale-105 transition-transform">
                            Select Music Folder
                        </button>
                        <div class="flex items-center gap-2 bg-[#1e1e1e] p-2 rounded-lg">
                            <label for="visualizerSelector" class="text-sm font-medium text-gray-300 cursor-pointer">Visualizer:</label>
                             <select id="visualizerSelector" class="bg-[#121212] text-white text-sm rounded-md border-gray-600 focus:ring-[#00aaff] focus:border-[#00aaff] transition">
                                <option value="waveform">Waveform</option>
                                <option value="bars">Bars</option>
                                <option value="circular">Circular</option>
                                <option value="radialBars">Radial Bars</option>
                                <option value="mirrorBars">Mirror Bars</option>
                                <option value="filledWaveform">Filled Waveform</option>
                                <option value="radialWaveform">Radial Waveform</option>
                                <option value="expandingCircles">Expanding Circles</option>
                                <option value="starfield">Starfield</option>
                                <option value="symmetricBars">Symmetric Bars</option>
                                <option value="vortex">Vortex</option>
                                <option value="flower">Flower</option>
                                <option value="bouncingBalls">Bouncing Balls</option>
                                <option value="ripples">Ripples</option>
                                <option value="neonGrid">Neon Grid</option>
                                <option value="sunburst">Sunburst</option>
                                <option value="tunnel">Tunnel</option>
                                <option value="spirographic">Spirographic</option>
                                <option value="floatingBlocks">Floating Blocks</option>
                                <option value="confetti">Confetti</option>
                            </select>
                        </div>
                        <div class="flex items-center gap-2 bg-[#1e1e1e] p-2 rounded-lg">
                            <label for="organizeToggle" class="text-sm font-medium text-gray-300 cursor-pointer">Organize Files</label>
                            <button id="organizeToggle" role="switch" aria-checked="false" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors bg-gray-600">
                                <span class="inline-block w-4 h-4 transform bg-white rounded-full transition-transform translate-x-1"></span>
                            </button>
                        </div>
                    </div>
                </div>
            </main>

            <aside class="absolute top-0 right-0 w-[300px] h-full bg-[#1e1e1e] shadow-[-4px_0_10px_rgba(0,0,0,0.5)] z-20">
                 <div id="playlist" class="h-full overflow-y-auto p-2.5 scrollbar-thin">
                    <div class="flex items-center justify-center h-full">
                        <p class="text-center text-[#888]">Select a folder to load tracks</p>
                    </div>
                </div>
            </aside>
            
            <div id="organizePanel" class="absolute top-0 left-0 w-[300px] h-full bg-[#1e1e1e] shadow-[4px_0_10px_rgba(0,0,0,0.5)] z-40 p-2.5 hidden flex-col flex">
                <h3 id="organizePanelTitle" class="text-lg font-semibold text-white mb-3 shrink-0">Pending File Operations (0)</h3>
                <div id="organizeCommands" class="flex-1 bg-black/40 p-2 rounded-md overflow-y-auto font-mono text-xs text-gray-300 scrollbar-thin mb-3">
                    <!-- Commands will be injected here -->
                </div>
                <div class="shrink-0">
                    <p class="text-xs text-gray-400 mb-2">
                        <strong>Important:</strong> Move the <strong>.bat</strong> file into your music folder before running it.
                    </p>
                    <div class="flex items-center gap-2">
                        <button id="generateBatBtn" class="flex-1 bg-gradient-to-r from-[#00aaff] to-[#00ffee] text-white font-bold py-2 px-4 rounded-lg text-sm shadow-lg hover:scale-105 transition-transform">
                            Generate .bat
                        </button>
                        <button id="cancelOrganizeBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg text-sm transition-colors">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Footer Player -->
        <footer class="flex-shrink-0 bg-[#1a1a1a] flex items-center justify-between px-4 pt-2 pb-6 shadow-2xl z-30 border-t border-white/10">
            <div id="trackInfo" class="w-1/4">
              <div class="text-sm text-[#888]">No track selected</div>
            </div>

            <div class="flex-1 flex items-center gap-2 max-w-2xl">
                <!-- Player Controls -->
                <div id="playerControls" class="flex items-center justify-center gap-2">
                    <button id="prevBtn" title="Rewind (‚Üê)" class="relative w-11 h-9 inline-flex items-center justify-center bg-transparent rounded-lg transition-colors active:translate-y-px focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[#1a1a1a] focus:ring-[#00aaff] text-white hover:bg-white/5">
                        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m11 19-9-7 9-7v14z"></path><path d="m22 19-9-7 9-7v14z"></path>
                        </svg>
                    </button>
                    <button id="playPauseBtn" title="Play / Pause (Space)" class="w-14 h-14 flex items-center justify-center bg-white text-black rounded-full transition-transform hover:scale-105 active:scale-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[#1a1a1a] focus:ring-[#00aaff]">
                        <svg id="playIcon" viewBox="0 0 24 24" width="30" height="30" fill="currentColor" stroke="currentColor" stroke-width="0">
                            <path d="M8 5v14l11-7z"></path>
                        </svg>
                        <svg id="pauseIcon" viewBox="0 0 24 24" width="30" height="30" fill="currentColor" stroke="currentColor" stroke-width="0" style="display: none;">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
                        </svg>
                    </button>
                    <button id="nextBtn" title="Fast Forward (‚Üí)" class="relative w-11 h-9 inline-flex items-center justify-center bg-transparent rounded-lg transition-colors active:translate-y-px focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[#1a1a1a] focus:ring-[#00aaff] text-white hover:bg-white/5">
                        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m13 5 9 7-9 7V5z"></path><path d="m2 5 9 7-9 7V5z"></path>
                        </svg>
                    </button>
                    <button id="repeatBtn" title="Repeat" class="relative w-11 h-9 inline-flex items-center justify-center bg-transparent rounded-lg transition-colors active:translate-y-px focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[#1a1a1a] focus:ring-[#00aaff] text-white hover:bg-white/5">
                        <svg id="repeatIcon" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 1l4 4-4 4"></path>
                            <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
                            <path d="M7 23l-4-4 4-4"></path>
                            <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
                        </svg>
                        <svg id="repeatRegionIcon" viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                            <path d="M17 1l4 4-4 4"></path>
                            <path d="M3 11V9a4 4 0 0 1 4-4h14"></path>
                            <path d="M7 23l-4-4 4-4"></path>
                            <path d="M21 13v2a4 4 0 0 1-4 4H3"></path>
                            <rect x="7" y="10" width="10" height="4" rx="1"></rect>
                        </svg>
                    </button>
                </div>
                <!-- Timeline -->
                <div id="timelineWrapper" class="flex-1 flex items-center gap-3 min-w-[220px] relative">
                    <div id="currentTimeLabel" class="text-xs text-[#888] w-12 text-center">0:00</div>
                    <div class="w-full h-9 flex items-center group relative">
                        <div id="loopRegionBox" class="absolute h-9 top-1/2 -translate-y-1/2 bg-rose-500/50 cursor-move text-white text-xs font-mono select-none" style="display: none; z-index: 3; touch-action: none;">
                        </div>
                        
                        <svg id="timeline" class="w-full h-full cursor-pointer" viewBox="0 0 1000 36" preserveAspectRatio="none">
                            <rect x="0" y="15.5" width="1000" height="5" rx="2.5" class="fill-white/10"></rect>
                            <rect id="bufferedRect" x="0" y="15.5" width="0" height="5" rx="2.5" class="fill-white/20 transition-width duration-100"></rect>
                            <rect id="playedRect" x="0" y="15.5" width="0" height="5" rx="2.5" fill="url(#grad)"></rect>
                            <circle id="timelineHandle" cx="0" cy="18" r="7" class="fill-white opacity-0 group-hover:opacity-100 transition-opacity"></circle>
                            <defs>
                                <linearGradient id="grad" x1="0" x2="1">
                                    <stop offset="0%" stop-color="#00aaff"></stop>
                                    <stop offset="100%" stop-color="#00ffee"></stop>
                                </linearGradient>
                            </defs>
                        </svg>
                        <div id="timelineTooltip" class="absolute bottom-full mb-2 bg-black text-white text-xs px-2 py-1 rounded pointer-events-none" style="display: none;">0:00</div>
                    </div>
                    <div id="durationLabel" class="text-xs text-[#888] w-12 text-center">0:00</div>
                    <div id="loopRegionDisplay" class="absolute left-1/2 -translate-x-1/2 -bottom-3.5 text-xs text-rose-300 font-mono pointer-events-none" style="visibility: hidden;"></div>
                </div>
            </div>
            <div class="w-1/4 flex justify-end items-center gap-4 pr-2">
                <!-- Volume Control -->
                <div id="volumeControlContainer" class="flex items-center group relative">
                    <div id="volumePopover" class="absolute bottom-full mb-2 bg-black text-white text-xs px-2 py-1 rounded pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap">Volume: 100%</div>
                    <button id="volumeBtn" title="Mute / Unmute" class="relative w-11 h-9 inline-flex items-center justify-center bg-transparent rounded-lg transition-colors active:translate-y-px focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[#1a1a1a] focus:ring-[#00aaff] text-white hover:bg-white/5">
                        <svg id="volumeHighIcon" viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        </svg>
                        <svg id="volumeMidIcon" viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        </svg>
                        <svg id="volumeLowIcon" viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                        </svg>
                        <svg id="volumeMuteIcon" viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <line x1="23" y1="9" x2="17" y2="15"></line>
                            <line x1="17" y1="9" x2="23" y2="15"></line>
                        </svg>
                    </button>
                    <div class="w-0 group-hover:w-28 transition-all duration-300 ease-in-out overflow-hidden flex items-center gap-2 ml-1">
                        <div id="volumeBarContainer" class="w-24 h-5 flex items-center cursor-pointer">
                            <div class="w-full h-1.5 bg-gray-600 rounded-full relative">
                                <div id="volumeBarFill" class="h-full bg-gradient-to-r from-[#00aaff] to-[#00ffee] rounded-full"></div>
                                <div id="volumeBarHandle" class="absolute top-1/2 -translate-y-1/2 w-3.5 h-3.5 bg-white rounded-full -ml-1.5 pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Playback Speed -->
                <button id="playbackSpeedBtn" title="Playback Speed (scroll to change)" class="w-16 h-9 text-sm font-semibold inline-flex items-center justify-center bg-transparent rounded-lg transition-colors active:translate-y-px focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[#1a1a1a] focus:ring-[#00aaff] text-white hover:bg-white/5">
                    1.00x
                </button>
            </div>
        </footer>
        
        <audio id="audio" hidden></audio>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- STATE ---
    let tracks = [];
    let currentTrackIndex = null;
    let isPlaying = false;
    let loopState = 'off'; // 'off', 'track', 'region'
    let loopRegion = { start: null, end: null };
    let loopRegionDragState = {
        active: false,
        mode: null, // 'move', 'resize-start', 'resize-end'
        offset: 0 // For moving, stores pointer pos relative to region start
    };
    let isOrganizeMode = false;
    let queuedCommands = [];
    let isSeeking = false;
    let seekInterval = null;
    const playbackSpeeds = [0.75, 1.0, 1.25, 1.5, 1.75, 2.0];
    let currentSpeedIndex = playbackSpeeds.indexOf(1.0);
    let currentVisualizerType = 'waveform';
    
    // Visualizer-specific state
    let circleProps = [], stars = [], particles = [], balls = [], ripples = [], tunnelRadius = 0, spiroAngle = 0, blocks = [], confettiParticles = [];

    // --- DOM ELEMENTS ---
    const audio = document.getElementById('audio');
    const folderPicker = document.getElementById('folderPicker');
    const selectFolderBtn = document.getElementById('selectFolderBtn');
    const playlistContainer = document.getElementById('playlist');
    const trackInfoContainer = document.getElementById('trackInfo');
    const main = document.querySelector('main');
    
    // Player Controls
    const playerControls = document.getElementById('playerControls');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const playIcon = document.getElementById('playIcon');
    const pauseIcon = document.getElementById('pauseIcon');
    const nextBtn = document.getElementById('nextBtn');
    const prevBtn = document.getElementById('prevBtn');
    const repeatBtn = document.getElementById('repeatBtn');
    const repeatIcon = document.getElementById('repeatIcon');
    const repeatRegionIcon = document.getElementById('repeatRegionIcon');
    const playbackSpeedBtn = document.getElementById('playbackSpeedBtn');

    // Timeline
    const timelineWrapper = document.getElementById('timelineWrapper');
    const timeline = document.getElementById('timeline');
    const playedRect = document.getElementById('playedRect');
    const bufferedRect = document.getElementById('bufferedRect');
    const timelineHandle = document.getElementById('timelineHandle');
    const currentTimeLabel = document.getElementById('currentTimeLabel');
    const durationLabel = document.getElementById('durationLabel');
    const timelineTooltip = document.getElementById('timelineTooltip');
    const loopRegionBox = document.getElementById('loopRegionBox');
    const loopRegionDisplay = document.getElementById('loopRegionDisplay');
    
    // Volume Controls
    const volumeControlContainer = document.getElementById('volumeControlContainer');
    const volumePopover = document.getElementById('volumePopover');
    const volumeBtn = document.getElementById('volumeBtn');
    const volumeBarContainer = document.getElementById('volumeBarContainer');
    const volumeBarFill = document.getElementById('volumeBarFill');
    const volumeBarHandle = document.getElementById('volumeBarHandle');
    const volumeHighIcon = document.getElementById('volumeHighIcon');
    const volumeMidIcon = document.getElementById('volumeMidIcon');
    const volumeLowIcon = document.getElementById('volumeLowIcon');
    const volumeMuteIcon = document.getElementById('volumeMuteIcon');

    // Visualizer
    const canvas = document.getElementById('visualizer');
    const visualizerSelector = document.getElementById('visualizerSelector');
    
    // Organize Mode
    const organizeToggle = document.getElementById('organizeToggle');
    const organizePanel = document.getElementById('organizePanel');
    const organizePanelTitle = document.getElementById('organizePanelTitle');
    const organizeCommandsContainer = document.getElementById('organizeCommands');
    const generateBatBtn = document.getElementById('generateBatBtn');
    const cancelOrganizeBtn = document.getElementById('cancelOrganizeBtn');

    // --- AUDIO VISUALIZER ---
    let audioContext, analyser, source, animationFrameId;

    function setupVisualizer() {
        if (!audioContext) {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
            } catch (e) {
                console.error("Error setting up audio context:", e);
                return;
            }
        }
        drawVisualizer();
    }

    function drawBars(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const barWidth = (width / bufferLength) * 2.5;
        let x = 0;
        
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0.2, '#00ffee');
        gradient.addColorStop(1, '#00aaff');
        ctx.fillStyle = gradient;

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255.0) * height * 0.8;
            ctx.fillRect(x, height - barHeight, barWidth, barHeight);
            x += barWidth + 1;
        }
    }
    
    function drawWaveform(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        gradient.addColorStop(0, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        
        ctx.lineWidth = 2;
        ctx.strokeStyle = gradient;
        ctx.beginPath();

        const sliceWidth = width * 1.0 / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * height / 2;

            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
            x += sliceWidth;
        }
        ctx.lineTo(width, height / 2);
        ctx.stroke();
    }

    function drawCircular(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 5;
        
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        
        for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255.0) * (radius * 1.5);
            const angle = (i / bufferLength) * 2 * Math.PI;

            const x1 = centerX + Math.cos(angle) * radius;
            const y1 = centerY + Math.sin(angle) * radius;
            const x2 = centerX + Math.cos(angle) * (radius + barHeight);
            const y2 = centerY + Math.sin(angle) * (radius + barHeight);

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    }
    
    // --- NEW VISUALIZER EFFECTS ---

    function drawRadialBars(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = Math.min(width, height) / 2.5;
        
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 4;

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255.0) * maxRadius * 0.8;
            const angle = (i / bufferLength) * 2 * Math.PI;

            const x1 = centerX + Math.cos(angle) * (maxRadius * 0.2);
            const y1 = centerY + Math.sin(angle) * (maxRadius * 0.2);
            const x2 = centerX + Math.cos(angle) * (maxRadius * 0.2 + barHeight);
            const y2 = centerY + Math.sin(angle) * (maxRadius * 0.2 + barHeight);

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    }

    function drawMirrorBars(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const barWidth = width / bufferLength;
        let x = 0;
        
        const gradient = ctx.createLinearGradient(0, height/2, 0, height);
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(0.5, '#00ffee');
        gradient.addColorStop(1, '#00aaff');
        ctx.fillStyle = gradient;

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255.0) * (height / 2) * 0.8;
            ctx.fillRect(x, height / 2 - barHeight, barWidth, barHeight);
            ctx.fillRect(x, height / 2, barWidth, barHeight);
            x += barWidth + 1;
        }
    }

    function drawFilledWaveform(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.fillStyle = gradient;
        ctx.beginPath();

        const sliceWidth = width * 1.0 / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * height / 2;

            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
            x += sliceWidth;
        }
        ctx.lineTo(width, height / 2);
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    function drawRadialWaveform(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const centerX = width / 2;
        const centerY = height / 2;
        const baseRadius = Math.min(width, height) / 4;
        
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        for (let i = 0; i <= bufferLength; i++) {
            const angle = (i / bufferLength) * 2 * Math.PI;
            const v = dataArray[i % bufferLength] / 128.0; // Wrap around for a closed loop
            const radius = baseRadius + (v - 1) * 50; // (v-1) gives -1 to 1 range
            
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;

            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
    }

    function drawExpandingCircles(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const centerX = width / 2;
        const centerY = height / 2;
        
        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i];
        }
        const avg = sum / bufferLength;

        if (avg > 60) { // Threshold to create a new circle
            circleProps.push({
                x: centerX,
                y: centerY,
                radius: 10,
                alpha: 1,
                lineWidth: Math.random() * 5 + 1
            });
        }

        for (let i = circleProps.length - 1; i >= 0; i--) {
            const circle = circleProps[i];
            ctx.beginPath();
            ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(0, 170, 255, ${circle.alpha})`;
            ctx.lineWidth = circle.lineWidth;
            ctx.stroke();

            circle.radius += 2;
            circle.alpha -= 0.01;

            if (circle.alpha <= 0) {
                circleProps.splice(i, 1);
            }
        }
    }
    
    function initStars(width, height) {
        if (stars.length === 0) {
            for (let i = 0; i < 200; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: Math.random() * 2 + 1,
                    baseAlpha: Math.random() * 0.5 + 0.1
                });
            }
        }
    }
    function drawStarfield(ctx, dataArray, width, height) {
        initStars(width, height);
        let sum = dataArray.reduce((a, b) => a + b, 0);
        let avg = sum / dataArray.length;
        let bass = dataArray.slice(0, dataArray.length / 8).reduce((a, b) => a + b, 0) / (dataArray.length / 8);

        stars.forEach(star => {
            let alpha = star.baseAlpha + (bass / 255) * 0.5;
            let size = star.size + (avg / 255) * 2;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, size / 2, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    function drawSymmetricBars(ctx, dataArray, width, height) {
        const bufferLength = dataArray.length;
        const barWidth = (width / 2) / bufferLength;
        const centerX = width / 2;
        
        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        gradient.addColorStop(0, '#00ffee');
        gradient.addColorStop(0.5, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        ctx.fillStyle = gradient;

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255.0) * height * 0.8;
            // Draw right side
            ctx.fillRect(centerX + (i * barWidth), height - barHeight, barWidth - 1, barHeight);
            // Draw left side (mirrored)
            ctx.fillRect(centerX - ((i + 1) * barWidth), height - barHeight, barWidth - 1, barHeight);
        }
    }

    function initParticles(width, height) {
        if (particles.length === 0) {
            for (let i = 0; i < 100; i++) {
                particles.push({
                    angle: Math.random() * 2 * Math.PI,
                    radius: Math.random() * (Math.min(width, height) / 2),
                    speed: Math.random() * 2 + 0.5,
                    size: Math.random() * 2 + 1
                });
            }
        }
    }
    function drawVortex(ctx, dataArray, width, height) {
        initParticles(width, height);
        const centerX = width / 2;
        const centerY = height / 2;
        let bass = dataArray.slice(0, 10).reduce((a,b) => a+b, 0) / 10;
        
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        ctx.fillStyle = gradient;

        particles.forEach(p => {
            p.angle += 0.01 + (bass / 255) * 0.05;
            p.radius -= p.speed;
            if (p.radius < 1) {
                p.radius = Math.random() * (Math.min(width, height) / 2);
                p.angle = Math.random() * 2 * Math.PI;
            }
            
            const x = centerX + Math.cos(p.angle) * p.radius;
            const y = centerY + Math.sin(p.angle) * p.radius;

            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    function drawFlower(ctx, dataArray, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const numPetals = 8;
        const baseRadius = 20;
        let bass = dataArray.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
        let treble = dataArray.slice(dataArray.length-10, dataArray.length).reduce((a, b) => a + b, 0) / 10;
        
        const gradient = ctx.createLinearGradient(centerX - 100, centerY - 100, centerX + 100, centerY + 100);
        gradient.addColorStop(0, '#00ffee');
        gradient.addColorStop(1, '#00aaff');
        ctx.fillStyle = gradient;

        ctx.save();
        ctx.translate(centerX, centerY);
        for (let i = 0; i < numPetals; i++) {
            ctx.rotate((Math.PI * 2) / numPetals);
            const petalLength = baseRadius + (bass / 255) * 150;
            const petalWidth = baseRadius / 2 + (treble / 255) * 20;
            ctx.beginPath();
            ctx.ellipse(petalLength / 2, 0, petalLength / 2, petalWidth, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
    
    function initBalls(width) {
        if (balls.length === 0 || balls.length !== 128) {
            balls = [];
            for (let i = 0; i < 128; i++) { // Match analyser.frequencyBinCount
                balls.push({ x: (i / 128) * width, y: 0, vy: 0 });
            }
        }
    }
    function drawBouncingBalls(ctx, dataArray, width, height) {
        initBalls(width);
        const gravity = 0.5;
        
        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        gradient.addColorStop(0, '#00aaff');
        gradient.addColorStop(1, '#00ffee');
        ctx.fillStyle = gradient;

        for (let i = 0; i < dataArray.length; i++) {
            const ball = balls[i];
            const amp = (dataArray[i] / 255);

            if (ball.y >= height - 5 && amp > 0.5) {
                ball.vy = -amp * 15;
            }

            ball.vy += gravity;
            ball.y += ball.vy;

            if (ball.y > height - 5) {
                ball.y = height - 5;
                ball.vy = 0;
            }

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function drawRipples(ctx, dataArray, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        let bass = dataArray.slice(0, 10).reduce((a,b) => a+b, 0) / 10;

        if (bass > 150 && Math.random() > 0.95) { // Threshold for new ripple
             ripples.push({
                radius: 1,
                alpha: 1,
                lineWidth: 5
            });
        }

        for (let i = ripples.length - 1; i >= 0; i--) {
            const r = ripples[i];
            ctx.beginPath();
            ctx.arc(centerX, centerY, r.radius, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(0, 238, 238, ${r.alpha})`;
            ctx.lineWidth = r.lineWidth;
            ctx.stroke();

            r.radius += 2;
            r.alpha -= 0.01;
            r.lineWidth = Math.max(1, r.lineWidth - 0.05);

            if (r.alpha <= 0) {
                ripples.splice(i, 1);
            }
        }
    }

    function drawNeonGrid(ctx, dataArray, width, height) {
        const gridSize = 30;
        const amp = dataArray.reduce((a,b) => a+b, 0) / dataArray.length / 255.0;
        
        ctx.strokeStyle = `rgba(0, 238, 238, ${0.2 + amp * 0.8})`;
        ctx.lineWidth = 1 + amp * 2;
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00aaff';

        for (let x = 0; x <= width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }
        for (let y = 0; y <= height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
    }

    function drawSunburst(ctx, dataArray, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const numRays = 64;
        
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#00ffee');
        gradient.addColorStop(1, 'transparent');
        ctx.strokeStyle = gradient;

        for (let i = 0; i < numRays; i++) {
            const dataIndex = Math.floor(i * (dataArray.length / numRays));
            const rayLength = (dataArray[dataIndex] / 255) * Math.max(width, height) * 0.5;
            const angle = (i / numRays) * 2 * Math.PI;

            ctx.lineWidth = 1 + (dataArray[i] / 255) * 5;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(angle) * rayLength,
                centerY + Math.sin(angle) * rayLength
            );
            ctx.stroke();
        }
    }

    function drawTunnel(ctx, dataArray, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const bass = dataArray.slice(0,10).reduce((a,b)=>a+b, 0) / 10;
        tunnelRadius = tunnelRadius * 0.9 + bass; // Smooth the radius change

        for (let i = 10; i > 0; i--) {
            const radius = tunnelRadius + i * 20;
            const alpha = 1 - (i/10);
            ctx.beginPath();
            ctx.strokeStyle = `rgba(0, 238, 238, ${alpha * 0.5})`;
            ctx.lineWidth = 2;
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }
    }

    function drawSpirographic(ctx, dataArray, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const bass = dataArray.slice(0, dataArray.length/3).reduce((a,b)=>a+b, 0) / (dataArray.length/3);
        const mid = dataArray.slice(dataArray.length/3, 2*dataArray.length/3).reduce((a,b)=>a+b, 0) / (dataArray.length/3);
        
        const R = Math.min(width, height) / 3;
        const r = R / (2 + (bass / 255) * 4);
        const d = r + (mid / 255) * 50;

        spiroAngle += 0.05;
        
        ctx.strokeStyle = '#00ffee';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let t = 0; t < Math.PI * 4; t+=0.1) {
            const x = centerX + (R - r) * Math.cos(t) + d * Math.cos(((R - r) / r) * t + spiroAngle);
            const y = centerY + (R - r) * Math.sin(t) - d * Math.sin(((R - r) / r) * t + spiroAngle);
            if (t === 0) ctx.moveTo(x,y);
            else ctx.lineTo(x,y);
        }
        ctx.stroke();
    }
    
    function initBlocks(width) {
        if (blocks.length === 0) {
            for (let i = 0; i < 30; i++) {
                blocks.push({
                    x: Math.random() * width,
                    y: Math.random() * 2000,
                    size: Math.random() * 20 + 10,
                    speed: Math.random() * 2 + 1
                });
            }
        }
    }
    function drawFloatingBlocks(ctx, dataArray, width, height) {
        initBlocks(width);
        const amp = dataArray.reduce((a,b) => a+b, 0) / dataArray.length / 255;
        
        ctx.fillStyle = '#00aaff';
        ctx.strokeStyle = '#00ffee';
        
        blocks.forEach(b => {
            b.y -= b.speed * (1 + amp * 5);
            if (b.y < -b.size) {
                b.y = height + b.size;
                b.x = Math.random() * width;
            }

            ctx.fillRect(b.x, b.y, b.size, b.size);
            ctx.strokeRect(b.x, b.y, b.size, b.size);
        });
    }

    function drawConfetti(ctx, dataArray, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const bass = dataArray.slice(0, 10).reduce((a,b) => a+b, 0) / 10;
        
        if (bass > 200 && confettiParticles.length < 200) {
            for(let i=0; i<10; i++) {
                confettiParticles.push({
                    x: centerX,
                    y: centerY,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 2,
                    alpha: 1,
                    color: `hsl(${Math.random() * 360}, 100%, 70%)`
                });
            }
        }

        for (let i = confettiParticles.length - 1; i >= 0; i--) {
            const p = confettiParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // gravity
            p.alpha -= 0.01;

            if (p.alpha <= 0) {
                confettiParticles.splice(i, 1);
            } else {
                ctx.fillStyle = p.color.replace(')', `, ${p.alpha})`).replace('hsl', 'hsla');
                ctx.fillRect(p.x, p.y, p.size, p.size);
            }
        }
    }


    function drawVisualizer() {
        if (!isPlaying || !analyser) {
            cancelAnimationFrame(animationFrameId);
            return;
        }

        animationFrameId = requestAnimationFrame(drawVisualizer);
        const ctx = canvas.getContext('2d');
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);

        // Determine which data is needed
        const needsTimeDomain = ['waveform', 'filledWaveform', 'radialWaveform'].includes(currentVisualizerType);

        if (needsTimeDomain) {
            analyser.fftSize = 2048;
            const bufferLength = analyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            switch (currentVisualizerType) {
                case 'waveform':
                    drawWaveform(ctx, dataArray, width, height);
                    break;
                case 'filledWaveform':
                    drawFilledWaveform(ctx, dataArray, width, height);
                    break;
                case 'radialWaveform':
                    drawRadialWaveform(ctx, dataArray, width, height);
                    break;
            }

        } else { // Needs frequency data
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            switch (currentVisualizerType) {
                case 'bars':
                    drawBars(ctx, dataArray, width, height);
                    break;
                case 'circular':
                    drawCircular(ctx, dataArray, width, height);
                    break;
                case 'radialBars':
                    drawRadialBars(ctx, dataArray, width, height);
                    break;
                case 'mirrorBars':
                    drawMirrorBars(ctx, dataArray, width, height);
                    break;
                case 'expandingCircles':
                    drawExpandingCircles(ctx, dataArray, width, height);
                    break;
                case 'starfield':
                    drawStarfield(ctx, dataArray, width, height);
                    break;
                case 'symmetricBars':
                    drawSymmetricBars(ctx, dataArray, width, height);
                    break;
                case 'vortex':
                    drawVortex(ctx, dataArray, width, height);
                    break;
                case 'flower':
                    drawFlower(ctx, dataArray, width, height);
                    break;
                case 'bouncingBalls':
                    drawBouncingBalls(ctx, dataArray, width, height);
                    break;
                case 'ripples':
                    drawRipples(ctx, dataArray, width, height);
                    break;
                case 'neonGrid':
                    drawNeonGrid(ctx, dataArray, width, height);
                    break;
                case 'sunburst':
                    drawSunburst(ctx, dataArray, width, height);
                    break;
                case 'tunnel':
                    drawTunnel(ctx, dataArray, width, height);
                    break;
                case 'spirographic':
                    drawSpirographic(ctx, dataArray, width, height);
                    break;
                case 'floatingBlocks':
                    drawFloatingBlocks(ctx, dataArray, width, height);
                    break;
                case 'confetti':
                    drawConfetti(ctx, dataArray, width, height);
                    break;
            }
        }
    }
    
    // --- HELPER FUNCTIONS ---
    const formatTrackName = (fileName) => fileName.replace(/\.mp3$/i, '').replace(/_/g, ' ');
    const formatTime = (seconds) => {
        if (isNaN(seconds)) return '0:00';
        const floorSeconds = Math.floor(seconds);
        const min = Math.floor(floorSeconds / 60);
        const sec = floorSeconds % 60;
        return `${min}:${sec < 10 ? '0' : ''}${sec}`;
    };

    // --- UI RENDERING ---
    function updateVolumeUI() {
        // Hide all icons first
        [volumeHighIcon, volumeMidIcon, volumeLowIcon, volumeMuteIcon].forEach(icon => icon.style.display = 'none');

        const volume = audio.muted ? 0 : audio.volume;
        
        // Update bar and handle
        volumeBarFill.style.width = `${volume * 100}%`;
        volumeBarHandle.style.left = `${volume * 100}%`;

        // Update popover text
        if (audio.muted) {
            volumePopover.textContent = "Muted";
        } else {
            volumePopover.textContent = `Volume: ${Math.round(volume * 100)}%`;
        }

        if (audio.muted || audio.volume === 0) {
            volumeMuteIcon.style.display = 'block';
        } else if (audio.volume > 0.66) {
            volumeHighIcon.style.display = 'block';
        } else if (audio.volume > 0.33) {
            volumeMidIcon.style.display = 'block';
        } else {
            volumeLowIcon.style.display = 'block';
        }
    }
    
    function renderLoopRegionUI() {
        if (loopState !== 'region' || loopRegion.start === null || !audio.duration) {
            loopRegionBox.style.display = 'none';
            loopRegionDisplay.style.visibility = 'hidden';
            return;
        }

        const startPercent = (loopRegion.start / audio.duration) * 100;
        const endPercent = (loopRegion.end / audio.duration) * 100;

        loopRegionBox.style.left = `${startPercent}%`;
        loopRegionBox.style.width = `${endPercent - startPercent}%`;
        
        loopRegionDisplay.textContent = `Loop: ${formatTime(loopRegion.start)} - ${formatTime(loopRegion.end)}`;
        loopRegionDisplay.style.visibility = 'visible';

        loopRegionBox.style.display = 'block';
    }

    function updatePlayerUI() {
        // Play/Pause button state
        playIcon.style.display = isPlaying ? 'none' : 'block';
        pauseIcon.style.display = isPlaying ? 'block' : 'none';
        
        // Add/remove persistent focus ring on play/pause button
        if (isPlaying) {
            playPauseBtn.classList.add('shadow-[0_0_0_2px_#1a1a1a,0_0_0_4px_#00aaff]');
        } else {
            playPauseBtn.classList.remove('shadow-[0_0_0_2px_#1a1a1a,0_0_0_4px_#00aaff]');
        }

        // Repeat button state
        repeatBtn.classList.toggle('text-[#00ffee]', loopState !== 'off');
        repeatIcon.style.display = loopState === 'region' ? 'none' : 'block';
        repeatRegionIcon.style.display = loopState === 'region' ? 'block' : 'none';

        repeatBtn.querySelector('div.absolute')?.remove();
        if (loopState === 'track') {
            const dot = document.createElement('div');
            dot.className = 'absolute bottom-1 w-1 h-1 bg-[#00ffee] rounded-full';
            repeatBtn.appendChild(dot);
        }

        // Track Info
        const currentTrack = currentTrackIndex !== null ? tracks[currentTrackIndex] : null;
        if (currentTrack) {
            trackInfoContainer.innerHTML = `
                <div class="text-left overflow-hidden whitespace-nowrap">
                   <p class="text-sm font-semibold truncate" title="${currentTrack.displayName}">${currentTrack.displayName}</p>
                   <p class="text-xs text-[#888] truncate">${currentTrack.file.webkitRelativePath.split('/')[0] || 'Local Folder'}</p>
                </div>
            `;
        } else {
            trackInfoContainer.innerHTML = '<div class="text-sm text-[#888]">No track selected</div>';
        }
        
        // Disable controls for pending delete track
        const isDisabled = isOrganizeMode && !!currentTrack?.pendingDelete;
        playerControls.querySelectorAll('button').forEach(btn => btn.disabled = isDisabled);
        if(isDisabled) {
             playerControls.querySelectorAll('button').forEach(btn => btn.classList.add('opacity-50', 'cursor-not-allowed'));
             playPauseBtn.classList.remove('hover:scale-105');
        } else {
            playerControls.querySelectorAll('button').forEach(btn => btn.classList.remove('opacity-50', 'cursor-not-allowed'));
            playPauseBtn.classList.add('hover:scale-105');
        }
    }

    function highlightTrackInPlaylist(oldIndex, newIndex) {
        // Un-highlight the old track if it exists
        if (oldIndex !== null) {
            const oldItem = playlistContainer.querySelector(`[data-index='${oldIndex}']`);
            if (oldItem) {
                oldItem.classList.remove('bg-white/10', 'scale-[1.02]');
                oldItem.classList.add('hover:bg-white/5', 'hover:scale-[1.01]');
                const thumb = oldItem.querySelector('.shrink-0');
                if (thumb) {
                    thumb.classList.remove('bg-[#222]');
                    thumb.classList.add('bg-transparent', 'text-gray-500');
                    thumb.textContent = 'üíø';
                }
            }
        }

        // Highlight the new track if it exists
        if (newIndex !== null) {
            const newItem = playlistContainer.querySelector(`[data-index='${newIndex}']`);
            if (newItem && !tracks[newIndex].pendingDelete) {
                newItem.classList.add('bg-white/10', 'scale-[1.02]');
                newItem.classList.remove('hover:bg-white/5', 'hover:scale-[1.01]');
                const thumb = newItem.querySelector('.shrink-0');
                if (thumb) {
                    thumb.classList.add('bg-[#222]');
                    thumb.classList.remove('bg-transparent', 'text-gray-500');
                    thumb.textContent = '‚ñ∂Ô∏è';
                }
                newItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    }

    function renderPlaylist() {
        if (tracks.length === 0) {
            playlistContainer.innerHTML = `
                <div class="flex items-center justify-center h-full">
                    <p class="text-center text-[#888]">Select a folder to load tracks</p>
                </div>`;
            return;
        }

        playlistContainer.innerHTML = '';
        tracks.forEach((track, index) => {
            const isCurrent = index === currentTrackIndex;
            const item = document.createElement('div');
            
            const baseClasses = 'group flex items-center gap-3 p-2 mb-1.5 rounded-lg transition-all duration-150 ease-in-out relative';
            const stateClasses = [
                track.pendingDelete ? 'opacity-50 line-through' : '',
                isCurrent && !track.pendingDelete ? 'bg-white/10 scale-[1.02]' : 'hover:bg-white/5 hover:scale-[1.01]'
            ].join(' ');

            item.className = `${baseClasses} ${stateClasses}`;
            item.dataset.index = index;

            item.innerHTML = `
                <div class="w-12 h-12 rounded-md flex items-center justify-center text-3xl shrink-0 ${isCurrent && !track.pendingDelete ? 'bg-[#222]' : 'bg-transparent text-gray-500'}">
                    ${isCurrent && !track.pendingDelete ? '‚ñ∂Ô∏è' : 'üíø'}
                </div>
                <div class="overflow-hidden flex-1 track-name-container">
                    <p class="font-medium truncate text-sm text-white flex items-center gap-1.5">
                        ${track.displayName}
                        ${track.pendingRename ? `<span title="Pending rename"><svg class="w-3 h-3 text-[#00ffee]" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 20"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 18a.969.969 0 0 0 .933-1H9.067A.969.969 0 0 0 10 18Zm7.933-4a7.96 7.96 0 0 0-1.06-4.025a7.962 7.962 0 0 0-6.131-5.968V2.213a.969.969 0 0 0-1.933 0v1.794a7.962 7.962 0 0 0-6.131 5.968A7.96 7.96 0 0 0 2.067 14Z"/></svg></span>` : ''}
                    </p>
                    <p class="text-xs text-gray-400 truncate">${track.file.webkitRelativePath.split('/')[0] || 'Local File'}</p>
                </div>
                <div class="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1 transition-opacity bg-[#1e1e1e] p-1 rounded-md ${isOrganizeMode ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'}">
                    <button class="p-1 hover:bg-white/20 rounded edit-btn" title="Rename Track" ${track.pendingDelete ? 'disabled' : ''}>
                        <svg viewBox="0 0 20 20" width="16" height="16" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-11.202 11.202-3.214.002.002-3.214L13.586 3.586z"></path></svg>
                    </button>
                    <button class="p-1 hover:bg-white/20 rounded delete-btn" title="${track.pendingDelete ? 'Undo Delete' : 'Delete Track'}">
                        ${track.pendingDelete ? 
                            `<svg viewBox="0 0 20 20" width="16" height="16" fill="currentColor" class="text-yellow-400"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.707-10.293a1 1 0 00-1.414-1.414l-3 3a1 1 0 001.414 1.414L10 9.414l.293.293a1 1 0 001.414-1.414l-1-1z" clip-rule="evenodd"></path><path d="M10.707 10.293a1 1 0 00-1.414 1.414L10.586 13l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4a1 1 0 00-1.414-1.414L12 11.586l-1.293-1.293z" clip-rule="evenodd"></path></svg>` : 
                            `<svg viewBox="0 0 20 20" width="16" height="16" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd"></path></svg>`}
                    </button>
                </div>
            `;
            
            // Edit/Delete event listeners
            item.querySelector('.edit-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (track.pendingDelete) return;
                const nameContainer = item.querySelector('.track-name-container');
                const originalName = track.displayName;
                nameContainer.innerHTML = `<input type="text" value="${originalName}" class="w-full bg-transparent text-white text-sm p-0 m-0 border-b border-[#00aaff] focus:outline-none name-input"/>`;
                const input = nameContainer.querySelector('.name-input');
                input.focus();
                input.select();
                
                const handleSubmit = () => {
                    const newName = input.value.trim();
                    if(newName && newName !== originalName) {
                        handleTrackRename(track.id, newName);
                    } else {
                        renderPlaylist(); // Re-render to show original name
                    }
                };

                input.addEventListener('blur', handleSubmit);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') handleSubmit();
                    if (e.key === 'Escape') renderPlaylist();
                });
                input.addEventListener('click', (e) => e.stopPropagation());
            });

            item.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                handleTrackDelete(track.id);
            });
            
            item.addEventListener('click', () => playTrack(index));

            playlistContainer.appendChild(item);
        });
    }

    function renderOrganizePanel() {
        if (isOrganizeMode) {
            organizePanel.classList.remove('hidden');
            organizePanelTitle.textContent = `Pending File Operations (${queuedCommands.length})`;
            if (queuedCommands.length > 0) {
                organizeCommandsContainer.innerHTML = queuedCommands.map(cmd => 
                    `<div class="whitespace-pre">${cmd.display}</div>`
                ).join('');
            } else {
                organizeCommandsContainer.innerHTML = `<div class="text-center text-gray-400 p-4 font-sans">No operations queued. Rename or delete tracks to add them here.</div>`;
            }
        } else {
            organizePanel.classList.add('hidden');
        }
    }


    // --- CORE LOGIC ---
    function handleFilesChange(event) {
        const files = event.target.files;
        if (!files) return;

        const mp3Files = Array.from(files)
            .filter(file => file.name.endsWith('.mp3'))
            .map((file, index) => ({
                id: index,
                name: file.name,
                displayName: formatTrackName(file.name),
                file,
                url: URL.createObjectURL(file),
                pendingDelete: false,
                pendingRename: false,
            }));
        
        if (mp3Files.length > 0) {
            // Reset visualizer states
            circleProps = [];
            stars = [];
            particles = [];
            balls = [];
            ripples = [];
            tunnelRadius = 0;
            spiroAngle = 0;
            blocks = [];
            confettiParticles = [];
            
            tracks = mp3Files;
            currentTrackIndex = 0;
            queuedCommands = [];
            renderPlaylist();

            const track = tracks[currentTrackIndex];
            audio.src = track.url;
            audio.play().then(() => {
                isPlaying = true;
                if(audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                setupVisualizer();
            }).catch(e => console.error("Playback error:", e));
            updatePlayerUI();
        }
    }
    
    function playTrack(index) {
        if (index >= 0 && index < tracks.length) {
            const track = tracks[index];
            if (isOrganizeMode && track.pendingDelete) return;

            const oldIndex = currentTrackIndex;
            currentTrackIndex = index;
            highlightTrackInPlaylist(oldIndex, index);

            audio.src = track.url;
            audio.play().then(() => {
                isPlaying = true;
                if(audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                setupVisualizer();
            }).catch(e => console.error("Playback error:", e));

            updatePlayerUI();
        }
    }

    const findNextPlayableIndex = (startIndex, direction = 1) => {
        if (tracks.length === 0) return null;
        let nextIndex = (startIndex + direction + tracks.length) % tracks.length;
        let attempts = 0;
        while (isOrganizeMode && tracks[nextIndex].pendingDelete && attempts < tracks.length) {
            nextIndex = (nextIndex + direction + tracks.length) % tracks.length;
            attempts++;
        }
        return attempts < tracks.length ? nextIndex : null;
    };

    const handleNextTrack = () => {
        if (currentTrackIndex !== null) {
            const nextIndex = findNextPlayableIndex(currentTrackIndex, 1);
            if(nextIndex !== null) playTrack(nextIndex);
        }
    };
    
    const startSeeking = (direction) => {
        if (seekInterval) return; // Already seeking
        if (!audio.duration || audio.duration === 0) return;

        const seek = () => {
            const SEEK_STEP = 2; // Seek 2 seconds at a time
            const newTime = audio.currentTime + (SEEK_STEP * direction);
            audio.currentTime = Math.max(0, Math.min(audio.duration, newTime));
        };
        
        isSeeking = true;
        seek(); // Seek immediately
        seekInterval = setInterval(seek, 100);
    };

    const stopSeeking = () => {
        if (seekInterval) {
            clearInterval(seekInterval);
            seekInterval = null;
            isSeeking = false;
        }
    };

    const togglePlayPause = () => {
        if (!audio.src && tracks.length > 0) {
            playTrack(0);
            return;
        }
        if (isPlaying) {
            audio.pause();
        } else {
            audio.play().then(() => {
                if(audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            });
        }
    };
    
    const handleTrackDelete = (trackId) => {
        const trackIndex = tracks.findIndex(t => t.id === trackId);
        if (trackIndex === -1) return;
        const track = tracks[trackIndex];
        
        if (isOrganizeMode) {
             const existingCommandIndex = queuedCommands.findIndex(c => c.trackId === trackId);
             if (existingCommandIndex > -1) {
                 // If there's a rename, remove it. If it's a delete, undo it.
                 if(queuedCommands[existingCommandIndex].type === 'del') {
                    queuedCommands.splice(existingCommandIndex, 1);
                    track.pendingDelete = false;
                 }
             } else {
                queuedCommands.push({
                    type: 'del', trackId: trackId, 
                    display: `del "${track.file.webkitRelativePath.replace(/\//g, '\\')}"`, 
                    file: track.file 
                });
                track.pendingDelete = true;
             }
             if (track.id === tracks[currentTrackIndex]?.id && track.pendingDelete) {
                handleNextTrack();
             }
        } else {
             if (!window.confirm("Are you sure you want to remove this track from the playlist?")) return;
             
             const wasPlaying = trackId === tracks[currentTrackIndex]?.id;
             tracks.splice(trackIndex, 1);

             if (tracks.length === 0) {
                 audio.pause();
                 audio.src = '';
                 currentTrackIndex = null;
                 isPlaying = false;
             } else {
                if (wasPlaying) {
                    const newIndex = Math.min(trackIndex, tracks.length - 1);
                    playTrack(newIndex);
                } else if (trackIndex < currentTrackIndex) {
                    currentTrackIndex--;
                }
             }
        }
        renderPlaylist();
        updatePlayerUI();
        renderOrganizePanel();
    }
    
    const handleTrackRename = (trackId, newName) => {
        const track = tracks.find(t => t.id === trackId);
        if(!track) return;
        
        if (isOrganizeMode) {
            const originalFilename = track.name;
            const newFilename = `${newName}.mp3`;
            const path = track.file.webkitRelativePath.substring(0, track.file.webkitRelativePath.lastIndexOf('/') + 1);
            const originalPath = `${path}${originalFilename}`.replace(/\//g, '\\');
            
            // Remove previous commands for this track
            queuedCommands = queuedCommands.filter(c => c.trackId !== trackId);

            queuedCommands.push({
                type: 'ren', trackId,
                display: `ren "${originalPath}" "${newFilename}"`,
                file: track.file, newName: newFilename
            });
            track.displayName = newName;
            track.pendingRename = true;
        } else {
            track.displayName = newName;
        }
        renderPlaylist();
        updatePlayerUI();
        renderOrganizePanel();
    }
    
    const handleClearCommands = () => {
        queuedCommands = [];
        tracks.forEach(t => {
            t.displayName = formatTrackName(t.name);
            t.pendingDelete = false;
            t.pendingRename = false;
        });
        isOrganizeMode = false;
        toggleOrganizeModeUI(false);
        renderPlaylist();
        updatePlayerUI();
        renderOrganizePanel();
    };

    const handleGenerateScript = () => {
        const scriptContent = [
            '@echo off',
            'rem This script should be placed in the root music folder you selected in the app.',
            'cd /d "%~dp0"',
            'echo Applying file changes from this folder: %cd%',
            'echo.',
            ...queuedCommands.map(c => c.display),
            'echo.',
            'echo All operations complete.',
            'pause'
        ].join('\r\n');

        const blob = new Blob([scriptContent], { type: 'application/bat' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'organize_music.bat';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        handleClearCommands();
    };

    function resizeCanvas() {
        if (canvas.clientWidth !== canvas.width || canvas.clientHeight !== canvas.height) {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }
    }

    const toggleOrganizeModeUI = (active) => {
        const toggle = organizeToggle;
        const span = toggle.querySelector('span');
        toggle.setAttribute('aria-checked', active);
        if (active) {
            toggle.classList.remove('bg-gray-600');
            toggle.classList.add('bg-[#00aaff]');
            span.classList.remove('translate-x-1');
            span.classList.add('translate-x-6');
            main.classList.add('ml-[300px]');
            canvas.style.left = '300px';
            canvas.style.width = 'calc(100% - 600px)';
        } else {
            toggle.classList.add('bg-gray-600');
            toggle.classList.remove('bg-[#00aaff]');
            span.classList.add('translate-x-1');
            span.classList.remove('translate-x-6');
            main.classList.remove('ml-[300px]');
            canvas.style.left = '0';
            canvas.style.width = 'calc(100% - 300px)';
        }
    };

    // --- EVENT LISTENERS ---
    selectFolderBtn.addEventListener('click', () => folderPicker.click());
    folderPicker.addEventListener('change', handleFilesChange);

    playPauseBtn.addEventListener('click', togglePlayPause);
    
    // Rewind/Fast-Forward listeners
    prevBtn.addEventListener('pointerdown', () => startSeeking(-1));
    prevBtn.addEventListener('pointerup', stopSeeking);
    prevBtn.addEventListener('pointerleave', stopSeeking);

    nextBtn.addEventListener('pointerdown', () => startSeeking(1));
    nextBtn.addEventListener('pointerup', stopSeeking);
    nextBtn.addEventListener('pointerleave', stopSeeking);

    repeatBtn.addEventListener('click', () => {
        if (loopState === 'off') {
            loopState = 'track';
        } else if (loopState === 'track') {
            loopState = 'region';
            // If no region exists yet and track is loaded, create a default one
            if (loopRegion.start === null && audio.duration) {
                loopRegion.start = audio.duration * 0.25;
                loopRegion.end = audio.duration * 0.75;
            }
        } else { // region
            loopState = 'off';
            loopRegion = { start: null, end: null }; // Clear region when exiting mode
        }
        audio.loop = (loopState === 'track');
        updatePlayerUI();
        renderLoopRegionUI();
    });
    
    playbackSpeedBtn.addEventListener('click', () => {
        currentSpeedIndex = (currentSpeedIndex + 1) % playbackSpeeds.length;
        const newSpeed = playbackSpeeds[currentSpeedIndex];
        audio.playbackRate = newSpeed;
        playbackSpeedBtn.textContent = `${newSpeed.toFixed(2)}x`;
    });

    playbackSpeedBtn.addEventListener('wheel', (e) => {
        e.preventDefault(); // Prevent page from scrolling
        
        let nextIndex = currentSpeedIndex;
        if (e.deltaY < 0) { // Scrolling up
            nextIndex = Math.min(playbackSpeeds.length - 1, currentSpeedIndex + 1);
        } else { // Scrolling down
            nextIndex = Math.max(0, currentSpeedIndex - 1);
        }

        if (nextIndex !== currentSpeedIndex) {
            currentSpeedIndex = nextIndex;
            const newSpeed = playbackSpeeds[currentSpeedIndex];
            audio.playbackRate = newSpeed;
            playbackSpeedBtn.textContent = `${newSpeed.toFixed(2)}x`;
        }
    });

    visualizerSelector.addEventListener('change', (e) => {
        currentVisualizerType = e.target.value;
    });

    visualizerSelector.addEventListener('wheel', (e) => {
        e.preventDefault();
        const selectEl = e.currentTarget;
        const currentIndex = selectEl.selectedIndex;
        let nextIndex = currentIndex;

        if (e.deltaY < 0) { // Scrolling up
            nextIndex = Math.max(0, currentIndex - 1);
        } else { // Scrolling down
            nextIndex = Math.min(selectEl.options.length - 1, currentIndex + 1);
        }

        if (nextIndex !== currentIndex) {
            selectEl.selectedIndex = nextIndex;
            selectEl.dispatchEvent(new Event('change'));
        }
    });

    volumeBtn.addEventListener('click', () => {
        audio.muted = !audio.muted;
    });

    let isSeekingVolume = false;
    const handleVolumeInteraction = (e) => {
        const rect = volumeBarContainer.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const offsetX = clientX - rect.left;
        let newVolume = Math.max(0, Math.min(1, offsetX / rect.width));
        
        audio.volume = newVolume;
        if (newVolume > 0) {
            audio.muted = false;
        }
    };
    const handleVolumePointerMove = (e) => {
        if (isSeekingVolume) {
            handleVolumeInteraction(e);
        }
    };
    const handleVolumePointerUp = () => {
        isSeekingVolume = false;
        window.removeEventListener('pointermove', handleVolumePointerMove);
        window.removeEventListener('pointerup', handleVolumePointerUp);
    };
    volumeBarContainer.addEventListener('pointerdown', (e) => {
        isSeekingVolume = true;
        handleVolumeInteraction(e);
        window.addEventListener('pointermove', handleVolumePointerMove);
        window.addEventListener('pointerup', handleVolumePointerUp);
    });


    volumeControlContainer.addEventListener('wheel', (e) => {
        e.preventDefault();
        const step = 0.05;
        let newVolume = audio.volume;

        if (e.deltaY < 0) { // Scrolling up -> increase volume
            newVolume += step;
        } else { // Scrolling down -> decrease volume
            newVolume -= step;
        }

        // Clamp the volume between 0 and 1
        newVolume = Math.max(0, Math.min(1, newVolume));
        
        audio.volume = newVolume;

        // Unmute if user scrolls and volume is > 0
        if (newVolume > 0) {
            audio.muted = false;
        }
    });

    // Audio events
    audio.addEventListener('play', () => { isPlaying = true; updatePlayerUI(); drawVisualizer(); });
    audio.addEventListener('pause', () => { isPlaying = false; updatePlayerUI(); cancelAnimationFrame(animationFrameId); });
    audio.addEventListener('ended', () => { if (loopState !== 'track') handleNextTrack(); });
    audio.addEventListener('volumechange', updateVolumeUI);
    audio.addEventListener('timeupdate', () => {
        if (isSeeking || loopRegionDragState.active) return;

        // Region loop logic
        if (loopState === 'region' && loopRegion.end !== null && audio.currentTime >= loopRegion.end) {
            audio.currentTime = loopRegion.start;
        }

        const currentTime = audio.currentTime;
        const duration = audio.duration;
        const playedPercent = duration > 0 ? (currentTime / duration) * 1000 : 0;
        currentTimeLabel.textContent = formatTime(currentTime);
        playedRect.setAttribute('width', playedPercent);
        timelineHandle.setAttribute('cx', playedPercent);
    });
    audio.addEventListener('durationchange', () => {
        durationLabel.textContent = formatTime(audio.duration);
        // If we enter region loop mode before the track is loaded, create the default region now.
        if (loopState === 'region' && loopRegion.start === null) {
            loopRegion.start = audio.duration * 0.25;
            loopRegion.end = audio.duration * 0.75;
        }
        renderLoopRegionUI();
    });
    audio.addEventListener('progress', () => {
        if (audio.buffered.length > 0) {
            const bufferedEnd = audio.buffered.end(audio.buffered.length - 1);
            const bufferedPercent = audio.duration > 0 ? (bufferedEnd / audio.duration) * 1000 : 0;
            bufferedRect.setAttribute('width', bufferedPercent);
        }
    });
    
    // Timeline events
    const getTimeFromPointerEvent = (e) => {
        if (!audio.duration || audio.duration === 0) return 0;
        const rect = timeline.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const offsetX = clientX - rect.left;
        const percent = Math.max(0, Math.min(1, offsetX / rect.width));
        return percent * audio.duration;
    };

    const handleTimelinePointerMove = (e) => {
        if (!isSeeking) return;
        const currentTime = getTimeFromPointerEvent(e);
        audio.currentTime = currentTime;

        // Update tooltip during drag
        const rect = timeline.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const offsetX = clientX - rect.left;
        timelineTooltip.style.left = `${offsetX}px`;
        timelineTooltip.textContent = formatTime(currentTime);
    };

    const handleTimelinePointerUp = () => {
        isSeeking = false;
        window.removeEventListener('pointermove', handleTimelinePointerMove);
        window.removeEventListener('pointerup', handleTimelinePointerUp);
    };

    const handleTimelinePointerDown = (e) => {
        // If in region mode, do nothing on the timeline background.
        // Interaction is handled by the loop UI elements.
        if (loopState === 'region' || !audio.duration) return;

        isSeeking = true;
        audio.currentTime = getTimeFromPointerEvent(e);
        
        window.addEventListener('pointermove', handleTimelinePointerMove);
        window.addEventListener('pointerup', handleTimelinePointerUp);
    };

    timelineWrapper.addEventListener('pointerdown', handleTimelinePointerDown);

    timelineWrapper.addEventListener('pointerenter', () => { if(audio.duration > 0) timelineTooltip.style.display = 'block'; });
    timelineWrapper.addEventListener('pointerleave', () => { if(!isSeeking && !loopRegionDragState.active) timelineTooltip.style.display = 'none'; });
    timelineWrapper.addEventListener('pointermove', (e) => {
        if(isSeeking || loopRegionDragState.active) return;
        if (audio.duration > 0) {
          const rect = timeline.getBoundingClientRect();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const offsetX = clientX - rect.left;
          timelineTooltip.style.left = `${offsetX}px`;
          timelineTooltip.style.transform = 'translateX(-50%)';
          timelineTooltip.textContent = formatTime(getTimeFromPointerEvent(e));
        }
    });

    // Loop region box events
    const RESIZE_HANDLE_WIDTH = 10; // px
    loopRegionBox.addEventListener('pointermove', (e) => {
        if (loopRegionDragState.active) return;
        const rect = loopRegionBox.getBoundingClientRect();
        if (e.clientX - rect.left < RESIZE_HANDLE_WIDTH) {
            loopRegionBox.style.cursor = 'ew-resize';
        } else if (rect.right - e.clientX < RESIZE_HANDLE_WIDTH) {
            loopRegionBox.style.cursor = 'ew-resize';
        } else {
            loopRegionBox.style.cursor = 'move';
        }
    });
    
    loopRegionBox.addEventListener('pointerdown', (e) => {
        e.stopPropagation(); // Prevent timeline seek
        if (!audio.duration) return;

        loopRegionDragState.active = true;
        
        const rect = loopRegionBox.getBoundingClientRect();
        const pointerTime = getTimeFromPointerEvent(e);

        if (e.clientX - rect.left < RESIZE_HANDLE_WIDTH) {
            loopRegionDragState.mode = 'resize-start';
        } else if (rect.right - e.clientX < RESIZE_HANDLE_WIDTH) {
            loopRegionDragState.mode = 'resize-end';
        } else {
            loopRegionDragState.mode = 'move';
            loopRegionDragState.offset = pointerTime - loopRegion.start;
        }

        window.addEventListener('pointermove', handleLoopRegionDrag);
        window.addEventListener('pointerup', handleLoopRegionDragEnd);
    });

    function handleLoopRegionDrag(e) {
        if (!loopRegionDragState.active) return;
        const currentTime = getTimeFromPointerEvent(e);

        if (loopRegionDragState.mode === 'resize-start') {
            loopRegion.start = Math.max(0, Math.min(currentTime, loopRegion.end - 0.1));
        } else if (loopRegionDragState.mode === 'resize-end') {
            loopRegion.end = Math.min(audio.duration, Math.max(currentTime, loopRegion.start + 0.1));
        } else if (loopRegionDragState.mode === 'move') {
            const regionDuration = loopRegion.end - loopRegion.start;
            let newStart = currentTime - loopRegionDragState.offset;
            let newEnd = newStart + regionDuration;

            if (newStart < 0) {
                newStart = 0;
                newEnd = regionDuration;
            }
            if (newEnd > audio.duration) {
                newEnd = audio.duration;
                newStart = audio.duration - regionDuration;
            }
            loopRegion.start = newStart;
            loopRegion.end = newEnd;
        }
        renderLoopRegionUI();
    }

    function handleLoopRegionDragEnd() {
        loopRegionDragState.active = false;
        loopRegionDragState.mode = null;
        window.removeEventListener('pointermove', handleLoopRegionDrag);
        window.removeEventListener('pointerup', handleLoopRegionDragEnd);
    }

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;

        if (loopState === 'region' && audio.duration) {
            const step = 0.5; // seconds
            let changed = false;

            if (e.code === 'ArrowLeft') {
                e.preventDefault();
                if (e.ctrlKey) {
                    // Ctrl + Left: Shrink from right
                    loopRegion.end = Math.max(loopRegion.start + 0.1, loopRegion.end - step);
                } else {
                    // Left: Expand to left
                    loopRegion.start = Math.max(0, loopRegion.start - step);
                }
                changed = true;
            } else if (e.code === 'ArrowRight') {
                e.preventDefault();
                if (e.ctrlKey) {
                    // Ctrl + Right: Shrink from left
                    loopRegion.start = Math.min(loopRegion.end - 0.1, loopRegion.start + step);
                } else {
                    // Right: Expand to right
                    loopRegion.end = Math.min(audio.duration, loopRegion.end + step);
                }
                changed = true;
            }
            
            if (changed) {
                renderLoopRegionUI();
                return; // Don't process other shortcuts
            }
        }
        
        switch (e.code) {
            case 'Space': e.preventDefault(); togglePlayPause(); break;
            case 'ArrowRight': e.preventDefault(); startSeeking(1); break;
            case 'ArrowLeft': e.preventDefault(); startSeeking(-1); break;
            case 'ArrowUp':
            case 'ArrowDown':
                e.preventDefault();
                if (currentTrackIndex !== null) {
                    const direction = e.code === 'ArrowDown' ? 1 : -1;
                    const newIndex = findNextPlayableIndex(currentTrackIndex, direction);
                    if(newIndex !== null) playTrack(newIndex);
                }
                break;
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
            stopSeeking();
        }
    });
    
    // Organize Mode events
    organizeToggle.addEventListener('click', () => {
        isOrganizeMode = !isOrganizeMode;
        toggleOrganizeModeUI(isOrganizeMode);
        if(!isOrganizeMode) {
             handleClearCommands();
        } else {
             updatePlayerUI();
             renderPlaylist();
             renderOrganizePanel();
        }
    });
    generateBatBtn.addEventListener('click', handleGenerateScript);
    cancelOrganizeBtn.addEventListener('click', handleClearCommands);

    // --- INITIALIZATION ---
    function init() {
        audio.volume = 1.0;
        updatePlayerUI();
        updateVolumeUI();

        // Set initial canvas width, accounting for the right-side playlist
        canvas.style.width = 'calc(100% - 300px)';

        // Use a ResizeObserver for robust canvas resizing whenever its dimensions change.
        // This is more reliable than listening for 'resize' and 'transitionend' events.
        const resizeObserver = new ResizeObserver(() => {
            resizeCanvas();
        });
        resizeObserver.observe(canvas);
        
        resizeCanvas(); // Set initial size
    }

    init();
});
</script>
</body>
</html>